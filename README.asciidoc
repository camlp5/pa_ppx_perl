`pa_ppx_perl`: a PPX Rewriter for Perl-ish regexp operations
============================================================
:toc:
:toc-placement: preamble

OCaml has support for regular expressions using a number of different
packages: `str`, `pcre`, and `re`.  These all present a functional
interface with a number of different verbs and data-types, and any
sort of nontrivial pattern-matching or match-and-replace involves
significant code that can fairly be described as boilerplate.  This
code is a pain to read/understand and to maintain as requirements
change.

By contrast, in Perl regular expressions are integrated into the
language, in such a way that matching, extracting substrings, and
match-and-replace are compactly expressed with little superfluous
boilerplate.  The result is that, once one has a grasp of the syntax
of regular expression *integration into the language*, the use of
regexps in Perl is transparent in a way that is difficult-to-match in
other languages.

This package is a first attempt to bring that level of transparency to
OCaml.  This package supports:

* regexp matching (`[%match ....]`)
* splitting with regexps (`[%split ....]`)
* pattern-substitution with the result of regexp matching or OCaml string-typed variables (`[%pattern ...]`)
* match-and-replace either once or globally (`[%subst ...]`)

All of these transparent syntax for "modifiers" in the style of Perl's
modifiers, and a few extra ones for OCaml specifically.

To introduce the capabilities of this package, I'll first provide
examples, and then explain the syntax and capabilities of the
system. As always, the tests are an excellent place to look usage
hints.

== Installation

To install, it should suffice to `opam install pa_ppx_perl`; from
source, `make all install` in the top-level directory should do the
trick.

== Invocation

To invoke the PPX rewriter for a source file, the package
`pa_ppx_perl` must be specified, viz.

```
ocamlfind ocamlc -package pa_ppx_perl -c -syntax camlp5o ppx_perl.ml
```
and similarly when linking (there is a small runtime support package required
```
ocamlfind ocamlc -package pa_ppx_perl -linkpkg -linkall -o ppx_perl.exe ppx_perl.cmo
```

== Examples

=== A match regexp with capture groups (like Perl's `m/.../`)

In Perl we can break the "shebang" line in `$x` into a directory and
the filename in that directory:

```
$x =~ m,^#!(\S+)/([^/\s]+),
```

And afterwards, we can use `$&` for the entire matched string, `$1`
for the directory part, and `$2` for the filename part.

In OCaml we can write:

```
[%match {|^#!(\S+)/([^/\s]+)|}]
```
of type
```
string -> (string * string option * string option) option
```

This corresponds to the entire match, both capture groups (which might
be empty), and of course the argument string might not match the
regexp.  Later we'll see how to simplify this.

=== Splitting a string with a regexp (like Perl's `split(/.../,...)`)

In Perl we can split a string with a regexp:

```
$x = "abcdaceabc" ;
split(/ab?c/, $x);
```

which returns the list `("", "d", "e")`

In OCaml we can write:

```
[%split {|ab?c|}] "abcdaceabc"
```
which returns the list `["d"; "e"]`.

NOTE WELL: there's a discrepancy here between Perl and OCaml's `re`.

In Perl we can also use capture-groups with a split:


```
$x = "abcdaceabc" ;
split(/a(b)?c/, $x);
```
which returns the list `['','b','d',undef,'e','b']`.

In OCaml, we can write
```
[%split {|a(b)?c|} / strings] "abcdaceabc"
```
which returns the list
```
[`Delim ("abc", Some "b");
 `Text "d";
 `Delim ("ac", None);
 `Text "e";
 `Delim ("abc", Some "b")]
```

This is much more complicated, so let's walk thru it:

* first, the delimiter, "abc", with the matched string, and then the (matched) capture-group.
* then the text "d"
* then the delimiter "ac" with an unmatched capture-group.
* then the text "e"
* then the delimiter "abc" again, with the matched capture group.

This is a lot of work, when we might not want it all, so there's a way
of limiting the amount of extracted substrings, that we'll come to
later.

NOTE the "strings" above. We'll come to this later on.

=== match-and-replace with a regexp/pattern (like Perl's `s/.../.../`)

In Perl we can match-and-replace:

```
$x = "abc\nabc"; $x =~ s,a(bc),<<$1>>,;
```
or (to refere to local Perl variables)
```
$lhs = "<<" ; $rhs = ">>" ;
$x = "abc\nabc"; $x =~ s,a(bc),${lhs}$1${rhs},;
```
and afterward, `$x` has value `"<<bc>>\nabc"`.

In OCaml we can do the same:

```
[%subst {|a(bc)|} / {|<<$1>>|}] "abc\nabc"
```
or (to refer to local OCaml variables)
```
let lhs = "<<" ;;
let rhs = ">>" ;;
[%subst {|a(bc)|} / {|${lhs}$1${rhs}|}] "abc\nabc"
```
with value `"<<bc>>\nabc"`.

In Perl instead of a *pattern* for the right-hand-side of the
substition, we can use a Perl expression, in which special variables
can be used to access the capture-groups:

```
$lhs = "<<" ; $rhs = ">>" ;
$x = "abc\nabc"; $x =~ s,a(bc),$lhs . $1 . $rhs,e;
```

and likewise in OCaml:

```
let lhs = "<<" ;;
let rhs = ">>" ;;
[%subst {|a(bc)|} / {|lhs ^ $1$ ^ rhs|} / e] "abc\nabc"
```

NOTE the difference in the way that capture-groups are named in the
pattern vs. in the expression.  This is due to the need to conform to
Camlp5 antiquotation syntax.

=== patterns

Implicit in Perl's `s/re/pat/` match-and-replace operation is the idea
of a *pattern*.  Such a pattern can be either a string with
antiquotations for variables and capture-groups, or a Perl expression
with antiquotations for capture-groups (since expressions already
include variables).  So in OCaml we have a type of "pattern" for this,
and we've already seen both kinds just above.

First there are strings with antiquotations for variables and capture-groups:

```
[%pattern {|<<$1>>|}}
```
or
```
{|${lhs}$1${rhs}|}]
```
and then there expression with antiquotations for capture-groups:
```
[%pattern {|lhs ^ $1$ ^ rhs|} / e]
```

NOTE that just as in Perl `s///`, to indicate that the pattern is an
expression, we use the "modifier `e`.

In a string pattern, antiquotations are either `${varname}` or (for
capture groups) `$N` (or `${N}`) (where `N` is an integer constant).
In an expression variables are already expressible, and capture groups
are expressed as `$N$` (where `N` is an integer constant).

A pattern that doesn't have any capture-groups has type `string`; a
pattern that does have capture-groups has type `Re.Group.t -> string`
(since those capture-groups will have to be taken from some
already-matched regexp, and a matched regexp produces a `Re.Group.t`).

== The high-level syntax of these extensions

The extensions all have common syntax aspects.  Extensions look like:

* `[%match *regexp*]`
* `[%match *regexp* / *modifiers*]`
* `[%split *regexp*]`
* `[%split *regexp* / *modifiers*]`
* `[%pattern *pattern*]`
* `[%pattern *pattern* / *modifiers*]`
* `[%subst *regexp* / *pattern*]`
* `[%subst *regexp* / *pattern* / *modifiers*]`

There are four kinds of modifiers, and different kinds are allowed for different extensions:

* regexp compile-time modifiers: allowed for `match`, `split`, `subst`

** `i`: case-insensitive regexp
** `s`: treat string being matched as a single line (like Perl `/s`)
** `m`: treat string being matched as multiple lines (like Perl `/m`)

`m` and `s` are mutually-exclusive

* regexp output modifiers: allowed for `match`, `split`

** `exc`: raise `Not_found` if the regexp does not match or mandatory
    capture-groups did not match.

** `group`: return a `Re.Group.t`

** `strings`: return a tuple of `string option` for each capture-group

`group` and `strings` are mutually-exclusive.  Also, `strings` can
take parameters, which are explained below.

* pattern modifiers: allowed for `pattern` and `subst`

** `e`: the pattern is an OCaml expression, not a string

* substitution modifiers: allowed for `subst`

** `g`: apply the substitution to every occurrence of the regexp, not just the first one

=== The `group` and `strings` modifiers

A regexp, when applied to some input string, can match, or fail to
match.  The most primitive result it can produce is a `Re.Group.t`,
which holds the substrings of the input that matched the capture
groups of the regexp.  So the result type of a regexp match should be
``` Re.Group.t option ```

With the `exc` modifier (which causes `Not_found` to be raised on
match failure), this becomes `Re.Group.t`.

But a `Re.Group.t` is a complex object and we might want something
more *transparent*.  A natural thing to want, is a tuple of all the
capture-groups.  So let's consider a regexp: `(a)?(b)(c)?`.  This
regexp has *four* capture groups:

* `0`: the entire matched substring
` `1`: the substring that matches `(a)`
` `2`: the substring that matches `(b)`
` `3`: the substring that matches `(c)`

If the regexp matches the string input, capture group `0` will be
non-null.  But capture groups `1`,`3` can be null even if the regexp
matches the string input.  Capture group `2` must match if the string
matches, but let's ignore that for now.  So a *transparent* type for a
*successful match* would be
```
string * string option * string option * string option
```
and a *transparent type the result of a regexp match (which might fail) would be
```
(string * string option * string option * string option) option
```

With the `exc` modifier we get the former type, but this is still
pretty cumbersome to handle.  Suppose that we only want capture group
`2`, and if it isn't matched, we'd like an exception.  That is,
capture group `2` is *mandatory*.  Then the modfiier `exc strings !2`
would produce the result type `string` (and only capture group `2`).
If we wanted capture groups `1`, `3`, we would use the modifier
`exc strings (!1, !3)`, and the result type would be `string * string`

== The supported PPX extensions



=== Match regexps

```
[%match {|...re...|}]
```

type:
```
string -> result
```

Modifiers

`i`:: case-insensitive matching
`exc`:: use exception match-failure instead option
`group`:: return the `Re.Group.t` object
`strings`:: [DEFAULT] return tuple of `string option` components for capture group

The type of result varies depending whether we're using exceptions for
match-failure or not.

If using exceptions, then the type of result is:
```
string * string option * ... * string option
```

where the # of `string option` corresponds to the # of actual capture groups in the regexp.

If using option, then the type of result is as above, but wrapped in an `option`.
For a regexp without any captures, this becomes `string option`

=== Split

```
[%split {|re-without-captures|}]
```

type: `string -> string list`

```
[%split {|re-with-captures|}]
```

type: 
```
string -> [`Text of string | `Delim of result]
```

The result is as in match regexps.

=== Substitution Patterns

```
[%pattern {|...pattern...|}]
```

```
[%pattern {|...expr...|} / e]
```

type: if the pattern uses any capture-group expressions (viz. `$1`, or `$1$`) then `Re.Group.t -> string`
else `string`.

In the first case, the pattern can contain $N or ${N} (where N is an
integer) and these will be replaced with calls to the N-th capture
group (where None gets mapped to the emptry string).  Other instances
of ${...} are treated as antiquotations and mapped to expressions.

In the second case, the expression is within a string, and can contain
$N$ (where N is an integer) and these are treated as $N above.  The
expression is parsed by the current parser, then that AST is used for
the r.h.s. of the pattern.

So both syntaxes support both capture-variables ($N/${N} vs. $N$) and
antiquotations (${...} vs plain expressions)

=== Match-and-replace

```
[%subst {|...re...|} / {|...pattern...|}]
```

```
[%subst {|...re...|} / {|...pattern...|} / ...modifiers...]
```

type: `string -> string`

This combines match-regexps and substitutions-patterns, and should be
understood as like the perl

```
s/re/pat/
```

Modifiers

`i` :: case-insensitive matching
`g` :: replace all matches
`e` :: pattern is an OCaml expression
